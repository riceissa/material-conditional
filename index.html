<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <link rel="stylesheet" href="css/style.css">

    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="module" src="https://js.withorbit.com/orbit-web-component.js"></script>

    <!-- Change these for each new page -->
    <link rel="canonical" href="https://riceissa.github.io/material-conditional/">
    <meta property="og:title" content="" />
    <meta property="og:site_name" content="" />
    <title>Understanding the material conditional</title>

  </head>
  <body>
    <article>
      <h1>Understanding the material conditional</h1>
      <p>by <a href="https://issarice.com/">Issa Rice</a></p>
      <p>August 18, 2021</p>
      <p>In this post we will explore the truth table of the material
      conditional. Students first learning formal logic or getting
      started with writing proofs are introduced to the idea of truth
      tables along with the usual logical connectives like \(\lnot\)
      (NOT), \(\land\) (AND), and \(\lor\) (OR). Everything goes well
      until the logical connective \(\implies\) (IMPLIES) is
      introduced. Why does a false statement imply everything? This is
      usually explained quite poorly, e.g., in terms of promises: a
      false antecedent means the condition of the promise never
      arises, so one automatically keeps the promise. As a beginner to
      math, I spent many <em>years</em> being confused about this.
      Just to give one aspect of my confusion, the explanation in
      terms of promises didn't make sense because it seemed suspicious
      that we were picking one specific way in which "if ..., then
      ..." was used in natural language and ignoring all the others.
      But then again, I didn't have the same problem with the logical
      OR connective: it always meant the inclusive OR in math, and I
      was fine to accept that. So why was I so confused about the
      material conditional? It seemed like I was not only confused
      about the truth table, but also, in my mind, confused
      about <em>why</em> I was confused; I couldn't articulate my own
      confusion.</p>

      <p>Like many in math, I eventually decided to accept it without
      understanding it because it just seemed to work.</p>

      <p>Many years later, I eventually hit upon core of my confusion,
      and also a way around this confusion. This is what I'd like to
      explain in this post</p>

      <p>In keeping with the above, the audience for this post is
      someone who has written some proofs before and has seen
      propositional logic and truth tables, but who still feels
      confused why the truth table for the material conditional is the
      way it is.</p>

      <p>Something mathematicians love to do is to discover and talk
      about recursive things. For instance, the famous Fibonacci
      sequence \(0, 1, 1, 2, 3, 5, 8, 13, 21, \ldots\) is defined as
      follows. We start with the numbers \(0\) and \(1\). Then, to
      find the next element of the sequence, we add the previous two
      elements together. So \(0+1 = 1\) is the third element. The
      fourth element is the sum of the second and third elements:
      \(1+1=2\). And then we have \(1+2=3\), \(2+3=5\), \(3+5=8\), and
      so on.</p>

      <p>This sequence is <em>recursively defined</em> because the
      sequence is defined in terms of itself: later elements are
      defined in terms of earlier elements.</p>

      <p>In this article, we will explore a striking example of
      recursion. Mathematicians have been reasoning about math and
      writing proofs for thousands of years, leading to many
      fascinating results about numbers, geometry, and equations.
      However, it turns out to be possible to point this machinery at
      itself, and to analyze mathematical reasoning using mathematical
      reasoning. This is like using a microscope not to study cells,
      but to study microscopes themselves!</p>

      <p>Why might we want to do this? Well, mathematicians are a
      weird and curious people, and delight in getting all
      self-referential to see what happens. It's also a fairly natural
      thought: as mathematicians, we have been reasoning in a
      particular way and gotten used to it. It has become our "hammer"
      and we see "nails" everywhere. From this perspective, our own
      mathematical reasoning is itself just another mathematical
      object we could be analyzing using our existing "hammer". Later
      on in the conclusion, I will discuss some other reasons why
      studying mathematical reasoning using mathematical reasoning is
      useful. But for now, I hope this curiosity-based reason (which
      is potentially just a wild and useless idea!) is sufficient to keep
      you interested.</p>

      <p>So how do we go about mathematically analyzing mathematical
      reasoning? As in many situations in math, it's easiest if we
      have an example to work with. Let's look at an argument showing
      that every integer (i.e., the positive and negative whole
      numbers together with zero) is exactly one of even or odd. You
      might think this is too obvious, and that's okay! The point
      right now isn't to discover <em>new</em> mathematics, but rather
      to examine the familiar in a new way. For that, an example that
      seems too simple is perfect.</p>

      <p>We will call an integer \(n\) <em>even</em> iff there is some
      integer \(k\) such that \(n = 2k\). This expresses the idea that
      an even number is a multiple of \(2\).</p>

      <p>Similarly, we will call an integer \(n\) <em>odd</em> iff
      there is some integer \(k\) such that \(n = 2k + 1\). This
      expresses the idea that an odd number is one more than an even
      number, i.e., an odd number is one that is half-way between two
      even numbers.</p>

      <p>Now that we have these two definitions, we can show that
      every integer is exactly one of even or odd. If you wish, you
      might want to try proving this yourself first, and then compare
      with what's below!</p>

      <p>First we show that every integer has at least one of the
      properties of being even or odd. To do this, we begin by
      restricting attention to the non-negative integers, and use
      induction. The number \(0\) is even because \(0 = 2\cdot 0\).
      Now suppose inductively that the number \(n\) is even or odd. We
      want to show that \(n+1\) is even or odd. If \(n\) happens to be
      even, there is some integer \(k\) such that \(n = 2k\). Thus we
      have \(n+1 = 2k+1\), so \(n+1\) is odd. If \(n\) happens to be
      odd, there is some integer \(k\) such that \(n = 2k+1\), so
      \(n+1 = (2k+1)+1 = 2k+2 = 2(k+1)\), which shows that \(n+1\) is
      even. This closes the induction, and shows that every
      non-negative integer is even or odd.</p>

      <p>We still have to show that each negative integer is even or
      odd. So suppose \(n\) is a negative integer. Then \(-n\) is a
      positive integer. By what we said in the previous paragraph,
      \(-n\) is even or odd. If \(-n\) is even, then we have \(-n =
      2k\) for some integer \(k\). Thus \(n = 2(-k)\); since \(-k\) is
      also an integer, this shows that \(n\) too is even. If \(-n\)
      happens to be odd, then we have \(-n = 2k+1\) for some integer
      \(k\). Thus \(n = -(2k+1) = -2k-1\). This isn't quite in the
      form we want. We can write \(-2k-1\) as \(2(-k)-1\), which is
      closer, but we still have a \(-1\) at the end instead of \(+1\).
      Here we use a trick that is pretty common, which is to add and
      subtract the same thing. This is like adding zero, which doesn't
      change the number. In this case, to get a \(+1\) at the end, we
      will subtract by \(1\), then add back the \(1\). So we get
      \(2(-k)-1-1+1\). This simplifies to \(2(-k)-2+1=2(-k-1)+1\).
      Thus, we have \(n = -(2k+1) = 2(-k-1)+1\). This shows that like
      \(-n\), the number \(n\) is also odd. This completes the part of
      our proof showing that every integer is even or odd.</p>

      <p>Next, we have to show that every integer is at most one of
      even or odd, i.e., that an integer can't be both even and odd at
      the same time. Suppose for the sake of contradiction that there
      is some integer \(n\) which is both even and odd. That means
      there is some integer \(k\) such that \(n = 2k\), and that there
      is some integer \(m\) such that \(n=2m+1\). It is very important
      that we use separate letters for \(k\) and \(m\), because the
      definitions for even and odd don't tell us that there is a
      single integer \(k\) such that \(n=2k=2k+1\). But at least we
      can say that \(n=2k=2m+1\). Concentrating just on the equation
      \(2k=2m+1\), we can rewrite this as \(2k-2m=1\), and then as
      \(2(k-m)=1\). Think for a moment what this equation means! By
      the definition of a number being even, this equation tells us
      that \(1\) is an even integer! From outside the proof, we know
      that \(1\) is not even, so we seem to be getting close to a
      contradiction. There are a few ways we could reach a
      contradiction. If we are willing to accept that the number
      \(1/2\) is not an integer, then we can just divide both side of
      the previous equation by \(2\) to get \(k-m=1/2\), which is a
      contradiction since \(k-m\) is an integer. Alternatively, we
      could argue that \(0 \leq 1 \leq 2\) so \(0 \leq 2(k-m) \leq
      2\). Dividing each part of the inequality by \(2\), this gives
      \(0 \leq k-m \leq 1\). Thus \(k-m\) is either \(0\) or \(1\).
      But if it is \(0\) we get \(1=2(k-m) = 2 \cdot 0 = 0\), and if
      it is \(1\) we get \(1 = 2(k-m) = 2\cdot 1 = 2\). In either case
      we have a contradiction.</p>

      <p>That was a lot to work through! You might be wondering, did
      we really have to work through such a real-world example of
      mathematical reasoning? The advantage is that now we have a lot
      of real math to work with. Like an anthropologist who studies
      people by observing them up close, we don't want to pontificate
      on mathematical reasoning in a vacuum; we really want to be
      familiar with how it works</p>

      <p>We can represent entire mathematical statements using letters
      like \(P, Q, R, \ldots\)&nbsp;, just like how in algebra we represent
      numbers using letters like \(a, b, c, \ldots\)&nbsp;.</p>

      <p>You are also familiar with how we can form new statements using existing statements. For example, the statement "both \(P\) and \(Q\) are true" is itself a statement. This kind of claim comes up so often that </p>

      <p>So why does the implication \(P \implies Q\) have the truth table that it does?</p>

      <p>In math, it is important to pay attention to your mental representations of things and to not conflate different things</p>

      <p>Looking at "if \(P\), then Q", we have two different interpretations/mental models of it:</p>

      <p>
        1. The mysterious new meaning textbooks are forcing on us: The logical connective \(\implies\), which turns it into a sentence with a specific truth value, described by the truth table.

        <p>A much more familiar meaning:
      2. As a rule of inference saying that once we have P, we are allowed to have Q.
      <p>
      TODO: things to add:
      - it's a fascinating fact that mathematical reasoning itself has such a concise formal description. we can easily imagine alternative worlds in which this was not the case, where mathematical reasoning itself is very complicated and messy even though the objects we study are simple formal systems.
      - we should think of it as a _theorem_ that what we think of as "if... then..." can be captured by a logical connective! this should not just be a "here's how we do things and you're gonna get used to it" thing!!!
    </article>
  </body>
</html>
